{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Small","text":"<p>C++ Small Containers</p> <p></p> <p></p> <ul> <li>Applications usually contain many auxiliary small data structures for each large collection of values. Container implementations often include several optimizations for the case when they are small.</li> <li>These optimizations cannot usually make it to the STL because of ABI compatibility issues. Users might need to reimplement these containers or rely on frameworks that include these implementations.</li> <li>Depending on large library collections for simple containers might impose a cost on the user that's higher than necessary and hinder collaboration on the evolution of these containers.</li> <li>This library includes independent implementations of the main STL containers optimized for the case when they are small.</li> </ul> <p></p> <p> </p> <p></p> <p> </p> <p></p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Integration:</p> CMake Add subdirectory <pre><code>git clone https://github.com/alandefreitas/small/\n</code></pre> <pre><code>add_subdirectory(small)\n# ...\nadd_executable(your_target main.cpp)\ntarget_link_libraries(your_target PUBLIC small::small)\n</code></pre> Fetch content <pre><code>include(FetchContent)\n\nFetchContent_Declare(small\n    GIT_REPOSITORY https://github.com/alandefreitas/small\n    GIT_TAG origin/master # or whatever tag you want\n)\n\nFetchContent_GetProperties(small)\nif(NOT small_POPULATED)\n    FetchContent_Populate(small)\n    add_subdirectory(${small_SOURCE_DIR} ${small_BINARY_DIR} EXCLUDE_FROM_ALL)\nendif()\n\n# ...\nadd_executable(your_target main.cpp)\ntarget_link_libraries(your_target PUBLIC small::small)\n</code></pre> External package <pre><code># Follow installation instructions and then... \nfind_package(small REQUIRED)\nif(NOT small_FOUND)\n    # Throw or put your FetchContent script here\nendif()\n\n# ...\nadd_executable(your_target main.cpp)\ntarget_link_libraries(your_target PUBLIC small::small)\n</code></pre> Install <p>Note</p> <p>Get the binary package from the release section. </p> <p>These binaries refer to the latest release version of small.</p> <p>Hint</p> <p>If you need a more recent version of <code>small</code>, you can download the binary packages from the CI artifacts or build the library from the source files.</p> Build from source <p>Note</p> <p>Ensure your C++ compiler and CMake are up-to-date and then:</p> Ubuntu + GCC <pre><code># Create a new directory\nmkdir build\ncd build\n# Configure\ncmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"-O2\"\n# Build\nsudo cmake --build . --parallel 2 --config Release\n# Install \nsudo cmake --install .\n# Create packages\nsudo cpack .\n</code></pre> Mac Os + Clang <pre><code># Create a new directory\nmkdir build\ncd build\n# Configure\ncmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"-O2\"\n# Build\ncmake --build . --parallel 2 --config Release\n# Install \ncmake --install .\n# Create packages\ncpack .\n</code></pre> Windows + MSVC <pre><code># Create a new directory\nmkdir build\ncd build\n# Configure\ncmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"/O2\"\n# Build\ncmake --build . --parallel 2 --config Release\n# Install \ncmake --install .\n# Create packages\ncpack .\n</code></pre> <p>Parallel Build</p> <p>Replace <code>--parallel 2</code> with <code>--parallel &lt;number of cores in your machine&gt;</code></p> <p>Setting C++ Compiler</p> <p>If your C++ compiler that supports C++17 is not your default compiler, make sure you provide CMake with the compiler location with the DCMAKE_C_COMPILER and DCMAKE_CXX_COMPILER options. For instance:</p> <pre><code>cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"-O2\" -DCMAKE_C_COMPILER=/usr/bin/gcc-8 -DCMAKE_CXX_COMPILER=/usr/bin/g++-8\n</code></pre> File amalgamation <p>Note</p> <p>Because containers are header-only, you can directly copy the contents from the <code>source</code> directory into your project.</p> <p>Hint</p> <p>In that case, you are responsible for setting the appropriate target include directories and any compile definitions you might require.</p> <p>Once the library is properly integrated, you can create containers from the namespace <code>small</code> like any other STL container:</p> <pre><code>//\n// Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com)\n//\n// Distributed under the Boost Software License, Version 1.0.\n// https://www.boost.org/LICENSE_1_0.txt\n//\n\n#include &lt;small/map.hpp&gt;\n#include &lt;small/queue.hpp&gt;\n#include &lt;small/set.hpp&gt;\n#include &lt;small/stack.hpp&gt;\n#include &lt;small/string.hpp&gt;\n#include &lt;small/vector.hpp&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;class R&gt;\nvoid\nprint(R&amp;&amp; v);\n\nvoid\nprint_codepoints(const small::string&amp; v);\n\nint\nmain() {\n    // Vector as usual\n    small::vector&lt;int&gt; v1 = { 1, 2, 3, 4, 5 };\n    print(v1); // 1 2 3 4 5\n\n    // Vector with inline storage for at least 10 elements\n    small::vector&lt;int, 10&gt; v2 = { 1, 2, 3, 4 };\n    v2.push_back(5);\n    print(v2); // 1 2 3 4 5\n\n    // Vector with inline storage only\n    small::max_size_vector&lt;int, 5&gt; v3 = { 1, 2, 3, 4 };\n    v3.push_back(5);\n    print(v3); // 1 2 3 4 5\n\n    // String\n    small::string s1 = \"Hello world!\";\n    print(s1); // H e l l o   w o r l d !\n\n    // String with custom inline storage\n    small::basic_string&lt;char, 40&gt; s2 = \"Hello world!\";\n    print(s2); // H e l l o   w o r l d !\n\n    // UTF8 String from larger UTF-32 string\n    small::string s3 = U\"This works too! \ud83d\ude00  \u00e9!\";\n    std::cout &lt;&lt; s3 &lt;&lt; '\\n'; // T h i s   w o r k s   t o o !   \ud83d\ude00\n    print_codepoints(s3);    // T|h|i|s| |w|o|r|k|s| |t|o|o|!| |\ud83d\ude00| | |\u00e9|!|\n\n    // Associative containers\n    small::set&lt;int&gt; a1 = { 2, 1, 5, 4, 3 };\n    print(a1); // 1 2 3 4 5\n\n    small::map&lt;int, int&gt; a2 = {\n        {1, 10},\n        {2, 20},\n        {3, 30},\n        {4, 40},\n        {5, 50}\n    };\n    print(a2); // &lt;1,10&gt; &lt;2,20&gt; &lt;3,30&gt; &lt;4,40&gt; &lt;5,50&gt;\n\n    small::multimap&lt;int, int&gt; a3 = {\n        {1, 10},\n        {1, 20},\n        {1, 30},\n        {1, 40},\n        {1, 50}\n    };\n    print(a3); // &lt;1,10&gt; &lt;1,20&gt; &lt;1,30&gt; &lt;1,40&gt; &lt;1,50&gt;\n\n    small::unordered_set&lt;int&gt; a4 = { 2, 1, 5, 4, 3 };\n    print(a4); // 2 1 5 4 3\n\n    // Container adaptors\n    small::stack&lt;int&gt; c1;\n    c1.push(1);\n    c1.push(2);\n    c1.push(3);\n    c1.push(4);\n    c1.push(5);\n    std::cout &lt;&lt; c1.top() &lt;&lt; '\\n'; // 5\n\n    small::queue&lt;int&gt; c2;\n    c2.push(1);\n    c2.push(2);\n    c2.push(3);\n    c2.push(4);\n    c2.push(5);\n    std::cout &lt;&lt; c2.front() &lt;&lt; '\\n'; // 1\n    std::cout &lt;&lt; c2.back() &lt;&lt; '\\n';  // 5\n\n    small::priority_queue&lt;int&gt; c3;\n    c3.push(1);\n    c3.push(2);\n    c3.push(3);\n    c3.push(4);\n    c3.push(5);\n    std::cout &lt;&lt; c3.top() &lt;&lt; '\\n'; // 5\n\n    return 0;\n}\n\ntemplate &lt;class R&gt;\nvoid\nprint(R&amp;&amp; v) {\n    for (const auto&amp; x: v) {\n        constexpr bool x_is_pair = small::detail::is_pair_v&lt;\n            std::decay_t&lt;decltype(x)&gt;&gt;;\n        if constexpr (not x_is_pair) {\n            std::cout &lt;&lt; x &lt;&lt; ' ';\n        } else {\n            std::cout &lt;&lt; '&lt;' &lt;&lt; x.first &lt;&lt; ',' &lt;&lt; x.second &lt;&lt; '&gt;' &lt;&lt; ' ';\n        }\n    }\n    std::cout &lt;&lt; \"\\n\";\n}\n\nvoid\nprint_codepoints(const small::string&amp; v) {\n    for (auto it = v.begin_codepoint(); it != v.end_codepoint(); ++it) {\n        std::cout &lt;&lt; *it &lt;&lt; '|';\n    }\n    std::cout &lt;&lt; \"\\n\";\n}\n</code></pre> <p>All containers are optimized for the case when they're small but also efficient when they are large. The containers mix the common techniques found in other small container libraries:</p> <ul> <li>Inline allocation for small containers</li> <li>Custom expected sizes</li> <li>Identification of relocatable types</li> <li>Custom growth factors with better defaults</li> <li>Communication with system memory allocators</li> <li>Explicit consideration of CPU cache sizes and branch prediction </li> </ul> <p>Most applications have many small lists and sets of elements. These containers avoid spending a lot of time with large containers that contain just a few elements. Small containers usually try to use the stack before dynamically allocating memory and try to represent associative containers with stack arrays, unless these sets are very large.</p> <p>The following containers are available:</p> <ul> <li><code>small::vector</code></li> <li><code>small::max_size_vector</code></li> <li><code>small::string</code></li> <li><code>small::set</code></li> <li><code>small::max_size_set</code></li> <li><code>small::multiset</code></li> <li><code>small::max_size_multiset</code></li> <li><code>small::unordered_set</code></li> <li><code>small::max_size_unordered_set</code></li> <li><code>small::unordered_multiset</code></li> <li><code>small::max_size_unordered_multiset</code></li> <li><code>small::map</code></li> <li><code>small::max_size_map</code></li> <li><code>small::multimap</code></li> <li><code>small::max_size_multimap</code></li> <li><code>small::unordered_map</code></li> <li><code>small::max_size_unordered_map</code></li> <li><code>small::unordered_multimap</code></li> <li><code>small::max_size_unordered_multimap</code></li> <li><code>small::stack</code></li> <li><code>small::queue</code></li> <li><code>small::priority_queue</code></li> </ul> <p>Although many compilers support small string optimization (SSO) already, this library will ensure all strings support SOO, custom inline sizes, relocation, and unicode.    </p>"},{"location":"references/","title":"References","text":"<p>These are some references we used for this work:</p> <ul> <li>Abseil</li> <li>Folly</li> <li>LLVM</li> <li>Boost Containers</li> <li>Tiny-utf8</li> </ul>"},{"location":"sets-and-maps/","title":"Sets and Maps","text":"<p>The small set/map classes use a more cache-friendly flat set/map and all other optimizations mentioned above for internal algorithms. As with other small containers, a custom template parameter can be used to define the number of inline elements in the container.</p> <p>The <code>small::default_inline_storage</code> and <code>small::is_relocatable</code> trait can also be defined for custom types, and all the usual set/map, ordered/unordered, uni/multi variants are also provided:</p> <pre><code>//\n// Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com)\n//\n// Distributed under the Boost Software License, Version 1.0.\n// https://www.boost.org/LICENSE_1_0.txt\n//\n\n#include &lt;small/map.hpp&gt;\n#include &lt;small/set.hpp&gt;\n#include &lt;iostream&gt;\n\n// A relocatable custom type whose default inline storage should be at least 10\n// elements\nstruct my_type\n{\n    int a;\n    double b;\n    friend bool\n    operator&lt;(const my_type &amp;lhs, const my_type &amp;rhs) {\n        return lhs.a &lt; rhs.a;\n    }\n};\n\nnamespace small {\n    template &lt;&gt;\n    struct is_relocatable&lt;my_type&gt; : std::true_type\n    {};\n    template &lt;&gt;\n    struct default_inline_storage&lt;my_type&gt; : std::integral_constant&lt;size_t, 10&gt;\n    {};\n} // namespace small\n\nint\nmain() {\n    // Inline storage for at least 5 elements\n    small::max_size_map&lt;int, my_type, 5&gt; v1 = {\n        {1, { 1, 1.1 }},\n        {2, { 2, 2.2 }},\n        {3, { 3, 3.3 }},\n        {4, { 4, 4.4 }},\n        {5, { 5, 5.5 }}\n    };\n    for (const auto &amp;x: v1) {\n        std::cout &lt;&lt; '&lt;' &lt;&lt; x.first &lt;&lt; ',' &lt;&lt; '&lt;' &lt;&lt; x.second.a &lt;&lt; ','\n                  &lt;&lt; x.second.b &lt;&lt; '&gt;' &lt;&lt; '&gt;' &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    // Default inline storage for at least 10 elements\n    small::unordered_multiset&lt;my_type&gt; v2 = {\n        {1, 1.1},\n        {2, 2.2},\n        {3, 3.3},\n        {4, 4.4},\n        {5, 5.5}\n    };\n    for (const auto &amp;x: v2) {\n        std::cout &lt;&lt; '&lt;' &lt;&lt; x.a &lt;&lt; ',' &lt;&lt; x.b &lt;&lt; '&gt;' &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre> <p>Unlike a <code>small::vector</code> or <code>small::string</code>, the asymptotic time complexities of flat sets/maps are very different from their <code>std::</code> counterparts and should only be used when they are small. Because they are internally implemented as arrays, manipulating these containers costs <code>O(n)</code>.</p> <p>For large containers, you can use <code>std</code> containers with custom allocators. Or for efficient large containers, you can use the abseil containers, implemented as B+-trees.</p>"},{"location":"strings/","title":"Strings","text":"<p>The small string includes all the common optimizations for small vectors, and a custom template parameter to set how large we expect the string to be (in bytes).</p> <p>However, when strings are representing text, if there's one thing that makes them not small is not supporting UTF8. In addition to the common interface for strings, <code>small::string</code> includes extra functions to identify and work with UTF8 code points with random access.</p> <pre><code>//\n// Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com)\n//\n// Distributed under the Boost Software License, Version 1.0.\n// https://www.boost.org/LICENSE_1_0.txt\n//\n\n#include &lt;small/string.hpp&gt;\n#include &lt;iostream&gt;\n\nint\nmain() {\n    // Input is UTF32, but string stores it as UTF8\n    small::string str = U\"Hello \ud83c\udf0e!\";\n\n    // Accessing bytes\n    std::cout &lt;&lt; static_cast&lt;char&gt;(str[4]) &lt;&lt; '\\n'; // o\n    std::cout &lt;&lt; static_cast&lt;char&gt;(str[6]) &lt;&lt; '\\n'; // \ufffd\n\n    // Accessing codepoints\n    using cp_idx = small::string::codepoint_index;\n    std::cout &lt;&lt; str[cp_idx(4)] &lt;&lt; '\\n'; // o\n    std::cout &lt;&lt; str[cp_idx(6)] &lt;&lt; '\\n'; // \ud83c\udf0e\n\n    // Malformed unicode strings\n    assert(not small::is_malformed(str));\n    str[7] = 'a';\n    assert(small::is_malformed(str));\n\n    return 0;\n}\n</code></pre> <p>The problem of supporting UTF8 is easier to explain than it is to solve. Programming languages tend to solve this problem by (1) forbidding byte or substring access, and/or (2) allowing only access to code points with <code>O(n)</code> cost, where <code>n</code> is the number of code points. Because anything that forbids byte access would be incompatible with a C++ string, we allow direct byte access, and strings are allowed to be malformed unicode, which we can check with <code>small::is_malformed</code>. </p> <p>All capacity and access functions contain extra overloads that accept codepoint indexes, defined as a strong type, rather than byte indexes. By using these functions, one can ensure the string is never malformed. It's up to the user to decide whether these access functions are useful and worth it in a particular application.  </p> <p>Access to codepoints is provided with an inline lookup-table trick that allows us to access codepoints in <code>O(log m)</code> time, where <code>m</code> is the number of multibyte code points in the strings. When there are no multibyte codepoints in the string, the string works as usual and no extra memory is required for the table.</p>"},{"location":"vectors/","title":"Vectors","text":"<p>This small vector implementation includes:</p> <ul> <li>Inline allocation for small vectors</li> <li>Custom expected size</li> <li>Special treatment of relocatable types<ul> <li>Relocatable types can be moved with <code>memcpy</code>, bypassing destructors and constructors.</li> <li>Relocatable types are defined by default for POD types and aggregate types of PODs</li> <li>The <code>small::is_relocatable</code> traits can be used as an extension point for custom types</li> </ul> </li> <li>Better growth factors</li> <li>Consider the cache line size in allocations</li> <li>Heap allocations can be disabled with <code>small::max_size_vector</code></li> </ul> <p>When there are fewer elements than a given threshold, the elements are kept in a stack buffer for small vectors. Otherwise, the vector works as usual. However, if you are 100% sure you will never need more than <code>N</code> elements, you can use a <code>max_size_vector</code>, where elements are always inline. </p> <p>The default number of elements in a small vector is usually the number of elements we can already fit inline in a vector. For larger data types, the <code>default_inline_storage</code> trait can be used as an extension point where one can define how many elements a small vector of that type should contain by default. </p> <pre><code>//\n// Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com)\n//\n// Distributed under the Boost Software License, Version 1.0.\n// https://www.boost.org/LICENSE_1_0.txt\n//\n\n#include &lt;small/vector.hpp&gt;\n#include &lt;iostream&gt;\n\n// A relocatable custom type whose default inline storage should be at least 10\n// elements\nstruct my_type\n{\n    int a;\n    double b;\n};\n\nnamespace small {\n    template &lt;&gt;\n    struct is_relocatable&lt;my_type&gt; : std::true_type\n    {};\n    template &lt;&gt;\n    struct default_inline_storage&lt;my_type&gt; : std::integral_constant&lt;size_t, 10&gt;\n    {};\n} // namespace small\n\nint\nmain() {\n    // Inline storage for at least 5 elements\n    small::vector&lt;my_type, 5&gt; v1 = {\n        {1, 1.1},\n        {2, 2.2},\n        {3, 3.3},\n        {4, 4.4},\n        {5, 5.5}\n    };\n    for (const auto &amp;x: v1) {\n        std::cout &lt;&lt; '&lt;' &lt;&lt; x.a &lt;&lt; ',' &lt;&lt; x.b &lt;&lt; '&gt;' &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; \"\\n\"; // &lt;1,1.1&gt; &lt;2,2.2&gt; &lt;3,3.3&gt; &lt;4,4.4&gt; &lt;5,5.5&gt;\n\n    // Default inline storage for at least 10 elements\n    small::vector&lt;my_type&gt; v2 = {\n        {1, 1.1},\n        {2, 2.2},\n        {3, 3.3},\n        {4, 4.4},\n        {5, 5.5}\n    };\n    for (const auto &amp;x: v2) {\n        std::cout &lt;&lt; '&lt;' &lt;&lt; x.a &lt;&lt; ',' &lt;&lt; x.b &lt;&lt; '&gt;' &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; \"\\n\"; // &lt;1,1.1&gt; &lt;2,2.2&gt; &lt;3,3.3&gt; &lt;4,4.4&gt; &lt;5,5.5&gt;\n\n    return 0;\n}\n</code></pre> <p>When there's a reasonable default for the number of inline elements, this strategy avoids multiple vector type instantiations for different inline storage sizes. </p> <p>This small vector implementation used folly, abseil, and LLVM as a reference.</p>"},{"location":"contributing/contributors/","title":"Contributors","text":"<sub>Marcos Pontes</sub> <sub>Alan De Freitas</sub>"},{"location":"contributing/get-involved/","title":"Get Involved","text":"<ul> <li>Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If this library helps you create something interesting, please divulge it with the community.</li> <li>If you are a programmer with good ideas, please share these ideas with us.</li> <li>Academic collaboration is more than welcome. It'd be great to see this library help people write papers.</li> </ul>"},{"location":"contributing/guidelines/","title":"Guidelines","text":"<p>If contributing with code, please leave all warnings ON (<code>-DSMALL_BUILD_WITH_PEDANTIC_WARNINGS=ON</code>), use cppcheck, and clang-format.</p> <p>If contributing to the documentation, please edit <code>README.md</code> directly, as the files in <code>./docs</code> are automatically generated with mdsplit.</p>"},{"location":"contributing/ideas-and-roadmap/","title":"Ideas and Roadmap","text":"<p>Feel free to contribute new features to this library. For complex features and changes, consider getting feedback from the community first. Contributing to an existing code base with its conventions might seem obscure at first but please don't let that discourage you from sharing your ideas.</p> <p>There are many ways in which you can contribute to this library:</p> <ul> <li>Testing the library in new environments <sup>see 1, 2, 3 </sup></li> <li>Contributing with interesting examples <sup>see 1</sup></li> <li>Finding problems in this documentation <sup>see 1 </sup></li> <li>Finding bugs in general <sup>see 1, 2, 3, 4 </sup></li> <li>Whatever idea seems interesting to you</li> </ul> <p>The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are:</p> <ul> <li>\"I don't like this optional feature, so I removed/deprecated it\"</li> <li>\"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative</li> <li>\"I removed this feature, so I don't have to install/update ______\" but have not provided an equivalent alternative</li> <li>\"I'm creating this high-cost promise that we'll support __ forever\" but I'm not sticking around to keep that promise</li> </ul> <p>In doubt, please open a discussion first</p>"}]}